type Skill {
  name: String!
  id: String!
}

type SkillCategory {
  name: String!
  id: String!
}

type Prompt {
  id: String!
  question: String!
  type: String!
  correctAnswer: String
  choices: [String!]
}

type Certification {
  name: String!
  id: String!
}

interface RequirementFor @relationshipProperties {
  minRating: Int
  minSkills: Int
  minProjects: Int
}

type Knowledge {
  name: String!
  description: String!
  id: String!
  requiredPrompts: [Prompt!]!
    @relationship(
      type: "REQUIREMENT_FOR"
      direction: IN
      properties: "RequirementFor"
    )
  requiredCerts: [Certification!]!
    @relationship(
      type: "REQUIREMENT_FOR"
      direction: IN
      properties: "RequirementFor"
    )
  requiredSkills: [Skill!]!
    @relationship(
      type: "REQUIREMENT_FOR"
      direction: IN
      properties: "RequirementFor"
    )
  requiredCategories: [SkillCategory!]!
    @relationship(
      type: "REQUIREMENT_FOR"
      direction: IN
      properties: "RequirementFor"
    )
}

type Competency {
  levels: [Int!]!
  name: String!
  id: String!
}

type CompTreeNode @exclude {
  name: String!
  id: String!
  type: String!
  level: Int!
  parent: String
  description: String
}

type CompSupertreeNode @exclude {
  name: String!
  id: String!
  parent: String
}

type Query {
  getCompetencyTree(rootId: String!): [CompTreeNode!]!
    @cypher(
      statement: """
      MATCH (c:Competency {id: $rootId})-[:IS_PREREQUISITE*0..]->(k)
      OPTIONAL MATCH (k)<-[r:IS_PREREQUISITE]-(p)
      WHERE exists((p)<-[:IS_PREREQUISITE*0..]-(c))
      RETURN {name: k.name, id: k.id, type: labels(k)[0], level: COALESCE(r.level, 0), parent: p.id, description: COALESCE(k.description, '')}
      """
    )

  getCompetencyComposition: [CompSupertreeNode!]!
    @cypher(
      statement: """
      MATCH (c:Competency)
      OPTIONAL MATCH (c)<-[:LEADS_TO]-(p:Competency)
      RETURN {name: c.name, id: c.id, parent: p.id}
      """
    )
}

type Mutation { 
  addKnowledgeToTree(parentId: String!, knowledgeId: String!, level: Int!): Knowledge
    @cypher(
      statement: """
      MATCH (p {id: $parentId})
      MATCH (k:Knowledge {id: $knowledgeId})
      CREATE (p)-[:IS_PREREQUISITE {level: $level}]->(k)
      RETURN k
      """
    )

  mergeCompetency(id: String!, name: String!, levels: [Int!]!): Competency
    @cypher(
      statement: """
      MERGE (c:Competency {id: $id})
      ON CREATE
        SET c.name = $name, c.levels = $levels
      ON MATCH
        SET c.levels = $levels
      RETURN c
      """
    )
}
